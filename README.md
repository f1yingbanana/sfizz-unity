# :musical_keyboard: sfizz-unity
Sfizz for Unity is a wrapper around [**sfizz**](https://github.com/sfztools/sfizz) - an open source audio synthesizer capable of loading virutal instruments in [**sfz**](https://sfzformat.com/) files.

This Unity wrapper takes advantage of the exported C APIs in [**sfizz.h**](https://github.com/sfztools/sfizz/blob/0eceacee861ee9328f07e8672ded3f79f792441e/src/sfizz.h), and hides the details of making function calls to C++ in the [**Sfizz.cs**](https://github.com/f1yingbanana/sfizz-unity/blob/master/Packages/sfizz-unity/Runtime/Sfizz.cs) file. In addition, this package also comes with a simple audio player which interacts with the audio synthesizer. This player takes care of feeding in audio instructions (either generated by the UI or from a MIDI file) to the native library, then converting the returned buffers to a streaming [`AudioClip`](https://docs.unity3d.com/ScriptReference/AudioClip.html).

As this is a wrapper for sfizz, users need to obtain their own sfizz library. This can be built from source with the `SFIZZ_SHARED` flag on. Detailed instructions can be found [here](https://github.com/sfztools/sfizz). Note each target platform will require a specific library built on that platform, and once placed in Unity, the library must be configured accordingly (see [plugins](https://docs.unity3d.com/Manual/Plugins.html)).

## :musical_score: System Requirements
Unity 2018.4.0 or later versions. Feel free to try an older version and let me know if it works.

## :control_knobs: Installation
The package is available on the [openupm registry](https://openupm.com/). You can install it via [openupm-cli](https://github.com/openupm/openupm-cli):
```
openupm add dev.f1yingbanana.sfizz-unity
```
You can also install this [via Unity Package Manager](https://docs.unity3d.com/Manual/upm-ui-giturl.html) with the following git url:
```
https://github.com/f1yingbanana/sfizz-unity.git#upm
```

## :notes: Getting Started
### :microphone: Obtaining the sfizz library
[**sfizz**](https://github.com/sfztools/sfizz) library must be built on each of the Unity project's target platform. On Windows, we are looking for the **sfizz.dll** file. On macOS, we are looking for **sfizz.dylib**. Currently their releases on GitHub do not contain library files we need, so we can either build it ourselves (locally or cloning then using GitHub CI), or ask in their Discord channel (they are very nice and helpful :innocent:).

### :accordion: Configuring library files
Once we obtained the library files, import them into Unity and set them up following [this guide](https://docs.unity3d.com/Manual/PluginInspector.html). **sfizz-unity** is a native plugin, by the way.

### :violin: Using the wrapper
At a high level, we tell **sfizz** what happened when (e.g. note C4 started to play at frame 114514), we then pass in a float array buffer for it to combine the events with our loaded virtual music instrument and fill out the array. Finally, we build an `AudioClip` out of that for Unity to play it in an `AudioSource`.

We create an instance of `Sfizz` and load the instrument:
```C#
Sfizz sfizz = new Sfizz();
sfizz.LoadPath("Path/To/My/Instrument.sfz");

// Default CD frequency, this should be the same as the frequency of the recorded samples of the virtual instrument.
int sampleRate = 44100;
float duration = 1f;
int totalSamples = (int)(frequency * duration);

// This means each time we render a buffer, we get one second worth of audio back, or in this case, 44100 samples.
sfizz.setSamplesPerBlock(totalSamples); 
```
Most of the parameters have acceptable default values, but do note that the default value for the render buffer is 1024, which is barely over 0.02 second at 48kHz frequency. This means we would need to chain multiple result buffers together to make coherent music, a.k.a. streaming. In this example, we set it to something a lot higher so we can generate a sound in one go out of convenience.

We are now ready to tell the library what happened. For example:
```C#
sfizz.SendNoteOn(/* delay= */ 0, /* pitch= */ 60, /* velocity= */ 64);
```
This starts a middle C with 64 velocity (range 0-127, bigger is louder), at the very beginning of the next buffer. Similarly, we can send other events, as long as the delay is between 0 and the numbeer we set in `setSamplesPerBlock`.

We can now "render" the events into actual audio, represented by floats in the range [-1, 1]. The render code looks like this:
```C#
// Create an audio clip that will be played by Unity at the end of this example.
AudioClip clip = AudioClip.Create("test", totalSamples, /* channels= */2, sampleRate, /* isStreaming= */ false);

// **sfizz** only supports stereo (a left and a right), channel count must be multiples of 2.
int channels = 2;
float[][] buffer = new float[channels][];
buffer[0] = new float[totalSamples];
buffer[1] = new float[totalSamples];
sfizz.RenderBlock(block, channels, totalSamples);

// AudioClip expects audio data to be in the form of L0, R0, L1, R1, ..., but sfizz returns us L0, L1, ..., R0, R1.
clip.SetData(Interleave(block), offset);
```
Where a vanilla interleave algorithm can be:
```C#
private float[] Interleave(float[][] input) {
  int channels = input.Length;
  int samples = input[0].Length;
  float[] output = new float[channels * samples];

  int k = 0;

  for (int i = 0; i < samples; i++) {
    for (int j = 0; j < channels; j++) {
      output[k++] = input[j][i];
    }
  }

  return output;
}
```

We can now play the `AudioClip` within an `AudioSource`, by adding all these code in a `MonoBehavior` script and attaching it to a `GameObject`.
```C#
AudioSource audioSource = gameObject.GetComponent<AudioSource>();
audioSource.clip = clip;
audioSource.Play();
```
And voila, notes in, sound out!
